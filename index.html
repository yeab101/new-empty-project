<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Shadow Fight â€“ Full Glow Version (Kick + Smooth)</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #04060a;
      overflow: hidden;
      touch-action: none;
      font-family: system-ui, sans-serif;
    }
    canvas {
      display: block;
      margin: auto;
      background: #05070b;
      border: 2px solid #262b33;
    }
  </style>
</head>
<body>
<canvas id="game" width="960" height="540"></canvas>

<script src="configs.js"></script>
<script>
// ===============================
// Image loader (external PNGs)
// ===============================
function loadImage(src) {
  const img = new Image();
  img.src = src;
  return img;
}

// Spritesheet and assets
const imgIdle    = loadImage("idle.png");
const imgRun     = loadImage("Run.png");
const imgAttack  = loadImage("Attack.png");
const imgKick    = loadImage("Kick.png");
const imgHit     = loadImage("Hit.png");
const imgDeath   = loadImage("Death.png");
const imgSlashFX = loadImage("SLASHFX.png");
const imgDojo    = loadImage("Arenabackground.png");
const imgGround  = loadImage("GROUNDSPRITE.png");
const imgHpBar   = loadImage("hp_bar.png");

// ===============================
// Canvas setup
// ===============================
const canvas = document.getElementById("game");
const ctx    = canvas.getContext("2d");
const W = canvas.width;
const H = canvas.height;

// Stage ground aligned to your background frame
const GROUND_Y = 450;

// ===============================
// Sprite definitions
// idle/run/attack/kick sheets: 4x2 (top row = blue, bottom = red)
// Hit/death: 4x2 as well, but wider frames
// ===============================
const SPRITES = {
  player: {
    idle:   { img: imgIdle,   fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    run:    { img: imgRun,    fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    attack: { img: imgAttack, fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    kick:   { img: imgKick,   fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    hit:    { img: imgHit,    fw: 384, fh: 512, frames: 4, cols: 4, row: 0 },
    // death uses 3 custom-configured frames from configs.js
    death:  { img: imgDeath,  fw: 384, fh: 512, frames: 3, cols: 4, row: 0 }
  },
  enemy: {
    // use the same top-row (blue) sprites as the player
    idle:   { img: imgIdle,   fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    run:    { img: imgRun,    fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    attack: { img: imgAttack, fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    kick:   { img: imgKick,   fw: 256, fh: 512, frames: 4, cols: 4, row: 0 },
    hit:    { img: imgHit,    fw: 384, fh: 512, frames: 4, cols: 4, row: 0 },
    // death uses 3 custom-configured frames from configs.js
    death:  { img: imgDeath,  fw: 384, fh: 512, frames: 3, cols: 4, row: 0 }
  }
};

// ===============================
// Character factory
// ===============================
function makeChar(x, facingLeft) {
  return {
    x,
    y: GROUND_Y,
    vx: 0,
    vy: 0,
    speed: 4,
    gravity: 1.2,
    onGround: true,
    facingLeft,
    anim: "idle",
    frame: 0,
    frameTimer: 0,
    frameSpeed: 4,   // LOWER = smoother/faster animation
    attacking: false,
    comboStep: 0,
    comboTimer: 0,
    attackCooldown: 0,
    hp: 100,
    alive: true,
    respawnTimer: 0
  };
}

// Place fighters inside background frame
const player = makeChar(W / 2 - 180, false); // blue
const enemy  = makeChar(W / 2 + 180, true);  // blue (same character as player)

// ===============================
// Input (keyboard + touch joystick)
// ===============================
let moveX = 0;
let keyLeft = false;
let keyRight = false;

window.addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft")  keyLeft  = true;
  if (e.key === "ArrowRight") keyRight = true;
  if (e.key === " ")          playerJump();
  if (e.key === "j" || e.key === "J") playerAttack();
  if (e.key === "k" || e.key === "K") playerKick();
});

window.addEventListener("keyup", (e) => {
  if (e.key === "ArrowLeft")  keyLeft  = false;
  if (e.key === "ArrowRight") keyRight = false;
});

// Virtual joystick + buttons (drawn with canvas)
const joyBase = { x: 120,    y: 430, r: 60 };
const joyKnob = { x: joyBase.x, y: joyBase.y, r: 35 };
let joyDragging = false;

const jumpBtn = { x: W - 130, y: H - 150, w: 90, h: 90 };
const atkBtn  = { x: W - 250, y: H - 120, w: 90, h: 90 };
const kickBtn = { x: W - 370, y: H - 150, w: 90, h: 90 };

canvas.addEventListener("touchstart", touchStart);
canvas.addEventListener("touchmove",  touchMove);
canvas.addEventListener("touchend",   touchEnd);

function rectHit(x, y, r) {
  return x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h;
}

function touchStart(e) {
  const t = e.touches[0];
  const x = t.clientX;
  const y = t.clientY;
  if (Math.hypot(x - joyBase.x, y - joyBase.y) <= joyBase.r) {
    joyDragging = true;
  }
  if (rectHit(x, y, jumpBtn)) playerJump();
  if (rectHit(x, y, atkBtn))  playerAttack();
  if (rectHit(x, y, kickBtn)) playerKick();
}

function touchMove(e) {
  if (!joyDragging) return;
  const t = e.touches[0];
  const x = t.clientX;
  const y = t.clientY;
  let dx = x - joyBase.x;
  let dy = y - joyBase.y;
  const dist = Math.hypot(dx, dy);
  const max  = joyBase.r - 15;
  if (dist > max) {
    dx = dx / dist * max;
    dy = dy / dist * max;
  }
  joyKnob.x = joyBase.x + dx;
  joyKnob.y = joyBase.y + dy;
  moveX = dx / max;
  if (Math.abs(moveX) < 0.2) moveX = 0;
}

function touchEnd() {
  joyDragging = false;
  moveX = 0;
  joyKnob.x = joyBase.x;
  joyKnob.y = joyBase.y;
}

// ===============================
// FX: Slash & Smoke
// ===============================
const fxList = [];

function spawnSlash(x, y, facingLeft) {
  fxList.push({ type: "slash", x, y, facingLeft, life: 28 });
}

function spawnSmoke(x, y) {
  fxList.push({ type: "smoke", x, y, life: 36 });
}

function updateFX() {
  for (let i = fxList.length - 1; i >= 0; i--) {
    fxList[i].life--;
    if (fxList[i].life <= 0) fxList.splice(i, 1);
  }
}

function drawFX() {
  fxList.forEach((fx) => {
    ctx.save();
    if (fx.type === "slash") {
      const fw = 512, fh = 1024;
      ctx.translate(fx.x, fx.y);
      if (fx.facingLeft) ctx.scale(-1, 1);

      ctx.globalAlpha = (fx.life / 28) * 1.2;
      ctx.shadowColor = fx.facingLeft
        ? "rgba(0,200,255,0.9)"
        : "rgba(255,80,80,0.9)";
      ctx.shadowBlur = 35;

      ctx.drawImage(
        imgSlashFX,
        0, 0, fw, fh,
        -fw * 0.3, -fh * 0.45,
        fw * 0.6, fh * 0.6
      );
    } else {
      // Rising smoke
      ctx.translate(fx.x, fx.y - (36 - fx.life) * 0.8);
      ctx.globalAlpha = fx.life / 36;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.beginPath();
      ctx.ellipse(0, 0, 32, 18, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  });
}

// ===============================
// Player + Enemy actions
// ===============================
function playerJump() {
  if (!player.onGround || !player.alive) return;
  player.vy = -18;
  player.onGround = false;
  spawnSmoke(player.x, player.y + 10);
}

function playerAttack() {
  if (!player.alive) return;
  if (player.attackCooldown > 0) return;
  player.comboStep = (player.comboStep + 1) % 3;
  player.comboTimer = 25;
  player.attacking = true;
  player.anim = "attack";
  player.frame = 0;
  player.attackCooldown = 10;
}

function playerKick() {
  if (!player.alive) return;
  if (player.attackCooldown > 0) return;
  player.attacking = true;
  player.anim = "kick";
  player.frame = 0;
  player.attackCooldown = 12; // slightly slower than punch
}

// Simple enemy AI: move in, attack/kick, respawn
function updateEnemyAI() {
  if (!enemy.alive) {
    enemy.vx = 0;
    if (enemy.respawnTimer > 0) {
      enemy.respawnTimer--;
    } else {
      enemy.hp = 100;
      enemy.alive = true;
      enemy.anim = "idle";
      enemy.frame = 0;
      enemy.x = W / 2 + 180;
      enemy.y = GROUND_Y;
    }
    return;
  }

  // If enemy is in hit-stun, let the hit animation play out
  if (enemy.anim === "hit") {
    enemy.vx = 0;
    return;
  }

  const dx   = player.x - enemy.x;
  const dist = Math.abs(dx);
  enemy.facingLeft = dx < 0;

  if (enemy.attacking) return;

  if (dist > 230) {
    enemy.vx = (dx > 0 ? 1 : -1) * enemy.speed * 0.8;
    enemy.anim = "run";
  } else {
    enemy.vx = 0;
    if (Math.random() < 0.02) {
      enemy.attacking = true;
      enemy.anim = Math.random() < 0.5 ? "attack" : "kick";
      enemy.frame = 0;
    } else {
      enemy.anim = "idle";
    }
  }
}

// ===============================
// Character update (smoothed)
// ===============================
function updateChar(ch, key) {
  const data = SPRITES[key][ch.anim];

  ch.vy += ch.gravity;
  ch.y  += ch.vy;
  if (ch.y > GROUND_Y) {
    ch.y = GROUND_Y;
    ch.vy = 0;
    ch.onGround = true;
  }

  ch.x += ch.vx;

  if (ch === player && ch.comboTimer > 0) {
    ch.comboTimer--;
    if (ch.comboTimer <= 0) ch.comboStep = 0;
  }

  if (ch.attackCooldown > 0) ch.attackCooldown--;

  // smoother animation (lower frameSpeed)
  ch.frameTimer++;
  if (ch.frameTimer >= ch.frameSpeed) {
    ch.frameTimer = 0;
    ch.frame++;

    if (ch.anim === "death") {
      if (ch.frame >= data.frames) ch.frame = data.frames - 1;
    } else if (ch.anim === "hit") {
      // After hit animation, go back to idle/run
      if (ch.frame >= data.frames) {
        ch.anim = ch.onGround ? "idle" : "run";
        ch.frame = 0;
      }
    } else if (ch.anim === "attack" || ch.anim === "kick") {
      if (ch.frame >= data.frames) {
        ch.attacking = false;
        ch.anim = ch.onGround ? "idle" : "run";
        ch.frame = 0;
      }
    } else {
      ch.frame = ch.frame % data.frames;
    }
  }
}

// ===============================
// Combat hit detection
// ===============================
let score = 0;
let timeSeconds = 0;
let comboDisplay = 0;
let comboDisplayTimer = 0;

function updateTimer() {
  timeSeconds++;
}

function checkHits() {
  // Player punching enemy
  if (
    player.attacking &&
    player.anim === "attack" &&
    player.frame === 2 &&
    enemy.alive
  ) {
    const range = 90;
    const dir   = player.facingLeft ? -1 : 1;
    const hitX  = player.x + dir * 70;
    if (Math.abs(hitX - enemy.x) < range) {
      const dmg = 12 + player.comboStep * 6;
      enemy.hp -= dmg;
      score    += dmg;
      comboDisplay = player.comboStep + 1;
      comboDisplayTimer = 30;

      spawnSlash(enemy.x, enemy.y - 90, player.facingLeft);
      spawnSmoke(enemy.x, enemy.y);

      // Stop enemy movement/attack when hit
      enemy.vx = 0;
      enemy.attacking = false;

      if (enemy.hp <= 0) {
        enemy.hp = 0;
        enemy.alive = false;
        enemy.anim = "death";
        enemy.frame = 0;
        enemy.respawnTimer = 90;
      } else {
        enemy.anim = "hit";
        enemy.frame = 0;
      }
    }
  }

  // Player kicking enemy
  if (
    player.attacking &&
    player.anim === "kick" &&
    player.frame === 2 &&
    enemy.alive
  ) {
    const range = 110;               // kick reaches further
    const dir   = player.facingLeft ? -1 : 1;
    const hitX  = player.x + dir * 85;
    if (Math.abs(hitX - enemy.x) < range) {
      const dmg = 14;                // kick damage
      enemy.hp -= dmg;
      score    += dmg;
      comboDisplay = 1;
      comboDisplayTimer = 20;

      spawnSlash(enemy.x, enemy.y - 90, player.facingLeft);
      spawnSmoke(enemy.x, enemy.y);

      // Stop enemy movement/attack when hit
      enemy.vx = 0;
      enemy.attacking = false;

      if (enemy.hp <= 0) {
        enemy.hp = 0;
        enemy.alive = false;
        enemy.anim = "death";
        enemy.frame = 0;
        enemy.respawnTimer = 90;
      } else {
        enemy.anim = "hit";
        enemy.frame = 0;
      }
    }
  }

  // Enemy punching player
  if (
    enemy.attacking &&
    enemy.anim === "attack" &&
    enemy.frame === 2 &&
    player.alive
  ) {
    const range = 90;
    const dir   = enemy.facingLeft ? -1 : 1;
    const hitX  = enemy.x + dir * 70;
    if (Math.abs(hitX - player.x) < range) {
      player.hp -= 10;
      spawnSlash(player.x, player.y - 90, enemy.facingLeft);
      spawnSmoke(player.x, player.y);

      // Stop player movement/attack when hit
      player.vx = 0;
      player.attacking = false;
      if (player.hp <= 0) {
        player.hp = 0;
        player.alive = false;
        player.anim = "death";
        player.frame = 0;
      } else {
        player.anim = "hit";
        player.frame = 0;
      }
    }
  }

  // Enemy kicking player
  if (
    enemy.attacking &&
    enemy.anim === "kick" &&
    enemy.frame === 2 &&
    player.alive
  ) {
    const range = 110;
    const dir   = enemy.facingLeft ? -1 : 1;
    const hitX  = enemy.x + dir * 85;
    if (Math.abs(hitX - player.x) < range) {
      player.hp -= 12;
      spawnSlash(player.x, player.y - 90, enemy.facingLeft);
      spawnSmoke(player.x, player.y);

      // Stop player movement/attack when hit
      player.vx = 0;
      player.attacking = false;
      if (player.hp <= 0) {
        player.hp = 0;
        player.alive = false;
        player.anim = "death";
        player.frame = 0;
      } else {
        player.anim = "hit";
        player.frame = 0;
      }
    }
  }
}

// ===============================
// Shadows under fighters
// ===============================
function drawShadow(x, y, scale) {
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.filter = "blur(6px)";
  ctx.beginPath();
  ctx.ellipse(x, y + 5, 60 * scale, 20 * scale, 0, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();
  ctx.restore();
}

// ===============================
// Glow + aura trail drawChar (no jitter)
// ===============================
function drawChar(ch, key) {
  const data = SPRITES[key][ch.anim];
  const img  = data.img;

  // Special case: use precise crop regions from configs.js for idle frames
  if (
    ch.anim === "idle" &&
    Array.isArray(window.IDLE_FRAMES_CONFIG) &&
    window.IDLE_FRAMES_CONFIG.length > 0
  ) {
    const idx = ch.frame % window.IDLE_FRAMES_CONFIG.length;
    const iconf = window.IDLE_FRAMES_CONFIG[idx];
    const sx = iconf.x;
    const sy = iconf.y;
    const fw = iconf.width;
    const fh = iconf.height;

    // Offscreen buffer for tint + glow, same style as other animations
    const off = document.createElement("canvas");
    off.width  = fw;
    off.height = fh;
    const octx = off.getContext("2d");

    // Base cropped frame
    octx.drawImage(img, sx, sy, fw, fh, 0, 0, fw, fh);

    // Tint inside sprite only (both characters use the same blue tint)
    octx.globalCompositeOperation = "source-atop";
    octx.fillStyle = "rgba(0,160,255,0.55)";
    octx.fillRect(0, 0, fw, fh);

    // Glow aura (same blue for both)
    octx.globalCompositeOperation = "lighter";
    octx.shadowColor = "rgba(0,180,255,0.9)";
    octx.shadowBlur = 35;
    octx.drawImage(off, 0, 0);

    // Draw to main canvas with stage scale
    ctx.save();
    ctx.translate(ch.x, ch.y);
    ctx.scale(0.78, 0.78);  // fight depth inside dojo
    if (ch.facingLeft) ctx.scale(-1, 1);

    // After-image trail
    ctx.globalAlpha = 0.18;
    ctx.filter = "blur(6px)";
    ctx.drawImage(off, -fw / 2, -fh, fw, fh);
    ctx.filter = "none";
    ctx.globalAlpha = 1;

    // Main sprite
    ctx.drawImage(off, -fw / 2, -fh, fw, fh);
    ctx.restore();
    return;
  }

  // Special case: use precise crop regions from configs.js for kick frames
  if (
    ch.anim === "kick" &&
    Array.isArray(window.KICK_FRAMES_CONFIG) &&
    window.KICK_FRAMES_CONFIG.length > 0
  ) {
    const idx = ch.frame % window.KICK_FRAMES_CONFIG.length;
    const kconf = window.KICK_FRAMES_CONFIG[idx];
    const sx = kconf.x;
    const sy = kconf.y;
    const fw = kconf.width;
    const fh = kconf.height;

    const off = document.createElement("canvas");
    off.width  = fw;
    off.height = fh;
    const octx = off.getContext("2d");

    // Base cropped frame
    octx.drawImage(img, sx, sy, fw, fh, 0, 0, fw, fh);

    // Tint inside sprite only (both characters use the same blue tint)
    octx.globalCompositeOperation = "source-atop";
    octx.fillStyle = "rgba(0,160,255,0.55)";
    octx.fillRect(0, 0, fw, fh);

    // Glow aura (same blue for both)
    octx.globalCompositeOperation = "lighter";
    octx.shadowColor = "rgba(0,180,255,0.9)";
    octx.shadowBlur = 35;
    octx.drawImage(off, 0, 0);

    // Draw to main canvas with stage scale
    ctx.save();
    ctx.translate(ch.x, ch.y);
    ctx.scale(0.78, 0.78);
    if (ch.facingLeft) ctx.scale(-1, 1);

    // After-image trail
    ctx.globalAlpha = 0.18;
    ctx.filter = "blur(6px)";
    ctx.drawImage(off, -fw / 2, -fh, fw, fh);
    ctx.filter = "none";
    ctx.globalAlpha = 1;

    // Main sprite
    ctx.drawImage(off, -fw / 2, -fh, fw, fh);
    ctx.restore();
    return;
  }

  // Special case: use precise crop regions from configs.js for death frames
  if (
    ch.anim === "death" &&
    Array.isArray(window.DEATH_FRAMES_CONFIG) &&
    window.DEATH_FRAMES_CONFIG.length > 0
  ) {
    const idx = Math.min(ch.frame, window.DEATH_FRAMES_CONFIG.length - 1);
    const dconf = window.DEATH_FRAMES_CONFIG[idx];
    const sx = dconf.x;
    const sy = dconf.y;
    const fw = dconf.width;
    const fh = dconf.height;

    // Offscreen buffer for tint + glow, same style as other animations
    const off = document.createElement("canvas");
    off.width  = fw;
    off.height = fh;
    const octx = off.getContext("2d");

    // Base cropped frame
    octx.drawImage(img, sx, sy, fw, fh, 0, 0, fw, fh);

    // Tint inside sprite only
    octx.globalCompositeOperation = "source-atop";
    // both player and enemy use the same blue character tint
    octx.fillStyle = "rgba(0,160,255,0.55)";
    octx.fillRect(0, 0, fw, fh);

    // Glow aura
    octx.globalCompositeOperation = "lighter";
    // unified blue glow for both characters
    octx.shadowColor = "rgba(0,180,255,0.9)";
    octx.shadowBlur = 35;
    octx.drawImage(off, 0, 0);

    // Draw to main canvas with stage scale
    ctx.save();
    ctx.translate(ch.x, ch.y);
    ctx.scale(0.78, 0.78);  // fight depth inside dojo
    if (ch.facingLeft) ctx.scale(-1, 1);

    // After-image trail
    ctx.globalAlpha = 0.18;
    ctx.filter = "blur(6px)";
    ctx.drawImage(off, -fw / 2, -fh, fw, fh);
    ctx.filter = "none";
    ctx.globalAlpha = 1;

    // Main sprite
    ctx.drawImage(off, -fw / 2, -fh, fw, fh);
    ctx.restore();
    return;
  }

  const fw   = data.fw;
  const fh   = data.fh;
  const cols = data.cols;
  const row  = data.row;

  const frameIndex = ch.frame % data.frames;
  const colIndex   = frameIndex % cols;

  const sx = colIndex * fw;
  const sy = row      * fh;

  // Offscreen isolated buffer for color + glow
  const off = document.createElement("canvas");
  off.width  = fw;
  off.height = fh;
  const octx = off.getContext("2d");

  // Base frame
  octx.drawImage(img, sx, sy, fw, fh, 0, 0, fw, fh);

    // Tint inside sprite only (both characters use the same blue tint)
    octx.globalCompositeOperation = "source-atop";
    octx.fillStyle = "rgba(0,160,255,0.55)";
  octx.fillRect(0, 0, fw, fh);

    // Glow aura (same blue for both)
    octx.globalCompositeOperation = "lighter";
    octx.shadowColor = "rgba(0,180,255,0.9)";
  octx.shadowBlur = 35;
  octx.drawImage(off, 0, 0);

  // Draw to main canvas with stage scale
  ctx.save();
  ctx.translate(ch.x, ch.y);
  ctx.scale(0.78, 0.78);  // fight depth inside dojo
  if (ch.facingLeft) ctx.scale(-1, 1);

  // Smooth after-image (no random jitter)
  ctx.globalAlpha = 0.18;
  ctx.filter = "blur(6px)";
  ctx.drawImage(off, -fw / 2, -fh, fw, fh);
  ctx.filter = "none";
  ctx.globalAlpha = 1;

  // Main sprite
  ctx.drawImage(off, -fw / 2, -fh, fw, fh);
  ctx.restore();
}

// ===============================
// HP Bars
// ===============================
function drawHpBar(x, y, w, h, hp, isEnemy) {
  const ratio = Math.max(0, hp) / 100;

  ctx.drawImage(imgHpBar, 0, 0, 1024, 256, x, y, w, h);

  ctx.save();
  ctx.beginPath();
  ctx.rect(x + 4, y + 4, (w - 8) * ratio, h - 8);
  ctx.clip();
  ctx.fillStyle = isEnemy
    ? "rgba(255,80,60,0.9)"
    : "rgba(80,230,255,0.9)";
  ctx.fillRect(x + 4, y + 4, (w - 8) * ratio, h - 8);
  ctx.restore();

  ctx.strokeStyle = "#000";
  ctx.strokeRect(x, y, w, h);
}

// ===============================
// Background & lighting
// ===============================
let bgScroll = 0;

function drawBackground() {
  bgScroll += 0.3;

  const bw = imgDojo.width;
  const bh = imgDojo.height;
  const scale = H / bh;
  const drawW = bw * scale;
  const offset = -(bgScroll * 0.15) % drawW;

  // Dojo parallax
  for (let i = -1; i <= 2; i++) {
    ctx.drawImage(
      imgDojo,
      0, 0, bw, bh,
      offset + i * drawW,
      0,
      drawW,
      H
    );
  }

  // Ground platform layer (repeating GROUNDSPRITE.png under fighters)
  const gw = imgGround.width;
  const gh = imgGround.height;
  const gScale = 1.0;
  const gDrawW = gw * gScale;
  const tiles = Math.ceil(W / gDrawW) + 2;
  const startX = -gDrawW;
  const groundY = GROUND_Y - gh * 0.5; // place platform so characters stand near the top surface

  for (let i = 0; i < tiles; i++) {
    ctx.drawImage(
      imgGround,
      0, 0, gw, gh,
      startX + i * gDrawW,
      groundY,
      gDrawW,
      gh
    );
  }
}

// Dark interior lighting so characters sit in the stage
function applyDojoLighting() {
  ctx.save();
  ctx.globalCompositeOperation = "multiply";
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "rgba(0,0,0,0.25)");
  g.addColorStop(1, "rgba(0,0,0,0.05)");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);
  ctx.restore();
}

// ===============================
// UI (joystick + buttons + HUD)
// ===============================
function drawUI() {
  // Joystick
  ctx.save();
  ctx.globalAlpha = 0.8;
  ctx.beginPath();
  ctx.arc(joyBase.x, joyBase.y, joyBase.r, 0, Math.PI * 2);
  ctx.fillStyle = "#1b222f";
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "#3af7ff";
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(joyKnob.x, joyKnob.y, joyKnob.r, 0, Math.PI * 2);
  ctx.fillStyle = "#0b111b";
  ctx.fill();
  ctx.strokeStyle = "#65f7ff";
  ctx.stroke();
  ctx.restore();

  // Jump button
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.arc(
    jumpBtn.x + jumpBtn.w / 2,
    jumpBtn.y + jumpBtn.h / 2,
    jumpBtn.w / 2,
    0, Math.PI * 2
  );
  ctx.fillStyle = "#35210e";
  ctx.fill();
  ctx.strokeStyle = "#f3c46e";
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.fillStyle = "#ffd27f";
  ctx.font = "bold 18px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("JUMP", jumpBtn.x + jumpBtn.w / 2, jumpBtn.y + jumpBtn.h / 2);
  ctx.restore();

  // Attack button
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.arc(
    atkBtn.x + atkBtn.w / 2,
    atkBtn.y + atkBtn.h / 2,
    atkBtn.w / 2,
    0, Math.PI * 2
  );
  ctx.fillStyle = "#3d1111";
  ctx.fill();
  ctx.strokeStyle = "#ff7b7b";
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.fillStyle = "#ffb0b0";
  ctx.font = "bold 18px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("ATK", atkBtn.x + atkBtn.w / 2, atkBtn.y + atkBtn.h / 2);
  ctx.restore();

  // Kick button
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.arc(
    kickBtn.x + kickBtn.w / 2,
    kickBtn.y + kickBtn.h / 2,
    kickBtn.w / 2,
    0, Math.PI * 2
  );
  ctx.fillStyle = "#112f3d";
  ctx.fill();
  ctx.strokeStyle = "#79d8ff";
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.fillStyle = "#b6ecff";
  ctx.font = "bold 18px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("KICK", kickBtn.x + kickBtn.w / 2, kickBtn.y + kickBtn.h / 2);
  ctx.restore();

  // HP bars
  drawHpBar(40, 30, 260, 22, player.hp, false);
  drawHpBar(W - 300, 30, 260, 22, enemy.hp, true);

  // Score + time
  ctx.fillStyle = "#fff";
  ctx.font = "16px system-ui";
  ctx.fillText("Score: " + score, 40, 70);
  const mins = Math.floor(timeSeconds / 60);
  const secs = timeSeconds % 60;
  ctx.fillText(
    "Time: " + mins + ":" + String(secs).padStart(2, "0"),
    W / 2 - 45,
    50
  );

  // Combo text
  if (comboDisplayTimer > 0 && comboDisplay > 1) {
    ctx.save();
    ctx.globalAlpha = comboDisplayTimer / 30;
    ctx.font = "bold 28px system-ui";
    ctx.fillStyle = "#ffdf5f";
    ctx.fillText(comboDisplay + " HIT COMBO!", W / 2 - 90, 90);
    ctx.restore();
  }
}

// ===============================
// Main loop
// ===============================
function gameLoop() {
  ctx.clearRect(0, 0, W, H);

  drawBackground();
  applyDojoLighting();

  // Movement input (keys + joystick)
  let dir = moveX;
  if (dir === 0) {
    if (keyLeft)  dir -= 1;
    if (keyRight) dir += 1;
  }
  if (!player.alive) dir = 0;

  player.vx = dir * player.speed;

  if (
    dir !== 0 &&
    player.onGround &&
    player.alive &&
    !player.attacking &&
    player.anim !== "hit"
  ) {
    player.anim = "run";
    player.facingLeft = dir < 0;
  } else if (
    player.onGround &&
    player.alive &&
    !player.attacking &&
    player.anim !== "hit"
  ) {
    player.anim = "idle";
  }

  updateEnemyAI();
  updateChar(player, "player");
  updateChar(enemy, "enemy");
  updateFX();
  checkHits();

  if (comboDisplayTimer > 0) comboDisplayTimer--;

  // Shadows make them sit in the scene
  drawShadow(player.x, player.y + 10, 0.9);
  drawShadow(enemy.x,  enemy.y  + 10, 0.9);

  // Characters + FX + UI
  drawChar(player, "player");
  drawChar(enemy,  "enemy");
  drawFX();
  drawUI();

  requestAnimationFrame(gameLoop);
}

// Start timers
setInterval(updateTimer, 1000);

// A tiny delay so images start loading
setTimeout(gameLoop, 200);
</script>
</body>
</html>
